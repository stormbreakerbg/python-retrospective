from collections import defaultdict, OrderedDict


def groupby(func, seq):
    """ Group values in seq on keys generated by func and return a dict. """
    return {key: [item for item in seq if func(item) == key]
            for key in (func(item) for item in seq)}


def compose(func1, func2):
    """ Return the composition of two functions. """
    return lambda arg: func1(func2(arg))


def iterate(func):
    """Return the iteration of `func`.

    Generate infinite sequence of compositions of `func`. The nth element
    in the sequence is the composition of (n - 1) functions.

    The first element is the identity function.

    """
    current_composition_func = lambda x: x

    while True:
        yield current_composition_func
        current_composition_func = compose(func, current_composition_func)


def zip_with(func, *iterables):
    """Generate sequence of elements where the nth element is the result of
    func applied to the nth elements of all iterables.

    """
    if len(iterables) == 0:
        return

    iterators = [iter(iterable) for iterable in iterables]

    while True:
        values = [next(iterator) for iterator in iterators]
        yield func(*values)


def cache(func, cache_size):
    """Return a function that caches the last `cache_size` results of `func`.

    Returns `func` if `cache_size` is <= 0

    """
    if cache_size <= 0:
        return func

    cache_store = OrderedDict()

    def cached_func(*args):
        if args not in cache_store:
            if len(cache_store) >= cache_size:
                cache_store.popitem(False)

            cache_store[args] = func(*args)

        return cache_store[args]

    return cached_func
